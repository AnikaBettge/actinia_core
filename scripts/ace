#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#######
# actinia-core - an open source REST API for scalable, distributed, high
# performance processing of geographical data that uses GRASS GIS for
# computational tasks. For details, see https://actinia.mundialis.de/
#
# Copyright (c) 2016-2018 SÃ¶ren Gebbert and mundialis GmbH & Co. KG
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
#######

import argparse
import requests
import simplejson
import time
from multiprocessing import Process, Queue
import sys
import os
import grass.script as grass
import subprocess
from pprint import pprint
from typing import List, Tuple, Optional, Dict
import click

__license__ = "GPLv3"
__author__     = "Soeren Gebbert"
__copyright__  = "Copyright 2016, Soeren Gebbert"
__maintainer__ = "Soeren Gebbert"
__email__      = "soerengebbert@googlemail.com"


"""
export ACTINIA_USER='demouser'
export ACTINIA_PASSWORD='gu3st!pa55w0rd'
export ACTINIA_URL='https://actinia.mundialis.de/latest'
"""

# Example script for actinia
"""
g.region res=1000 -p
r.univar map=elev+https://storage.googleapis.com/graas-geodata/elev_ned_30m.tif
r.info elev
r.slope.aspect elevation=elev slope=slope_elev+GTiff
r.info slope_elev
"""

# Example script for actinia
"""
# Example script for actinia shell interface
g.region rast=elevation -p
r.univar map=elevation
r.info elevation
r.slope.aspect -a elevation=elevation slope=slope_elev+GTiff
# r.mapcalc expression=slope_elev=100
r.info slope_elev
r.watershed elevation=elevation accumulation=acc+GTiff
r.info acc
r.neighbors input=elevation output=neighbour_elev+GTiff
r.info neighbour_elev
"""

# Default values
ACTINIA_USER='demouser'
ACTINIA_PASSWORD='gu3st!pa55w0rd'
ACTINIA_URL='https://actinia.mundialis.de/latest'
ACTINIA_AUTH=(ACTINIA_USER, ACTINIA_PASSWORD)

PCHAIN = {
    "version": "1",
    "list": list()
}


def set_credentials():
    """Read the environmental variables and set the actinia url and credentials

    Returns:

    """
    global ACTINIA_USER, ACTINIA_PASSWORD, ACTINIA_URL, ACTINIA_AUTH

    act_user = os.getenv("ACTINIA_USER")
    act_pass = os.getenv("ACTINIA_PASSWORD")
    act_url = os.getenv("ACTINIA_URL")

    if act_user is not None:
        ACTINIA_USER = act_user

    if act_pass is not None:
        ACTINIA_PASSWORD = act_pass

    if act_url is not None:
        ACTINIA_URL = act_url

    ACTINIA_AUTH=(ACTINIA_USER, ACTINIA_PASSWORD)


@click.command()
def actinia_version() -> None:
        url = ACTINIA_URL + "/version"
        r = requests.get(url, auth=ACTINIA_AUTH)
        print(r.text)


@click.command()
@click.option('--script', "-s", help="Execute all commands in a script")
def execute_script(script):

    f = open(script, "r")
    lines = f.readlines()

    commands = list()

    for line in lines:
        line = line.strip()
        # Get all lines that have no comments
        if "#" not in line[:1]:
            tokens = line.split()
            commands.append(tokens)

    send_poll_commands(commands=commands)


def send_poll_commands(commands: List[List[str]]) -> None:
    """Create the actinia process chain, send it to the actinia server
    and poll for the result

    Args:
        commands: A list of GRASS commands from the command line or from a script
    """

    for command in commands:
        p_chain = create_actinia_process(command)
        if p_chain:
            PCHAIN["list"].append(p_chain)

    # Read location and mapset
    mapset = grass.read_command("g.mapset", "p").strip()
    location = grass.read_command("g.gisenv", get="LOCATION_NAME")

    url = ACTINIA_URL + "/locations/%s/processing_async_export"%location
    r = requests.post(url, json=PCHAIN, auth=ACTINIA_AUTH)

    data = simplejson.loads(r.text)
    print("Resource status", data["status"])

    poll_url = data["urls"]["status"]

    print("Polling:", poll_url)

    while True:
        r = requests.get(poll_url, auth=ACTINIA_AUTH)

        try:
            data = simplejson.loads(r.text)
            print("Resource poll status:", data["status"])
            print(data["message"])

            if data["status"] == "finished" or data["status"] == "error" or data["status"] == "terminated":
                break
            time.sleep(1)
        except Exception as a:
            raise

    print("Resource status", data["status"])
    print("--------------------------------------------------------------------------")

    if r.status_code == 200:
        for entry in data["process_log"]:
            if entry["stdout"]:
                print(entry["stdout"])
            if entry["stderr"][0]:
                pprint(entry["stderr"])
        pprint(data["urls"])
    else:
        print(r.text)


def create_actinia_process(command: List[str]) -> Optional[dict]:
    """Create an actinia command dict, that can be put into a process chain

    Args:
        command: The GRASS GIS command as a list of strings

    Returns:
        The actinia process dictionary

    """
    if not command:
        return None

    if "--json" not in command:
        command.append("--json")

    print(command)

    proc = subprocess.Popen(args=command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                            stdin=subprocess.PIPE)
    (stdout_buff, stderr_buff) = proc.communicate()
    stdout_buff = stdout_buff.decode()
    stderr_buff = stderr_buff.decode()

    print(stdout_buff)

    if proc.returncode != 0:
        raise Exception("Error while executing GRASS command: %s. \n"
                        "\n%s\n%s\n"%(str(command), stdout_buff, stderr_buff))
    try:
        actinia_proc = simplejson.loads(stdout_buff)
        return actinia_proc
    except:
        raise


if __name__ == '__main__':
    set_credentials()

    if len(sys.argv) > 1:
        if sys.argv[1][0:2] in ["r.", "v.", "i.", "t.", "g.", "r3."]:
            send_poll_commands(commands=[sys.argv[1:],])
        else:
            execute_script()
    else:
        actinia_version()

